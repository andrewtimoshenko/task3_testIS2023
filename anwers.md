## 1. Невыровненный доступ к памяти

Разыменование такого указателя приведет к undefined behavior и может быть результатом падения программы.

Например:
```C
int8_t *buffer = malloc(64);
int32_t *pointer = (int32_t *)(buffer + 1);
*pointer = 42; // Error: misaligned integer pointer assignment
```

Решением может быть использование memcpy, которая умеет работать с невыровненными данными, но по информации, что я нашел, это может зависеть от компилятора:
```C
int8_t *buffer = malloc(64);
int32_t value = 42;
memcpy(buffer + 1, &value, sizeof(int32_t)); // Correct
```

Пример со структурой:
```C
struct A {
    int32_t i32;
    int64_t i64;
};
int8_t *buffer = malloc(32);
struct A *pointer = (struct A *)(buffer + 1);
pointer->i32 = 7; // Error: pointer is misaligned
```
В данном случае решением может быть упаковка структуры:
```C
struct A { ... } __attribute__((packed));
```

## 2. Идиома char buf[0];

Может быть полезным как последний элемент структуры переменной длины. Эта идиома известна как "“struct hack"

Пример из кода ядра Linux (https://android.googlesource.com/platform/hardware/bsp/kernel/qcom/qcom-msm8x09-v3.10/+/refs/heads/master/drivers/ieee1394/raw1394-private.h):
```C
struct iso_block_store {
        atomic_t refcount;
        size_t data_size;
        quadlet_t data[0];
};
```
И далее под него выделяется память, длина блока хранится в data_size:

```C
struct iso_block_store *store =
        malloc(sizeof(struct iso_block_store) +
                  sizeof(quadlet_t) * number_of_data_items);
```

Технически говоря, данный трюк - это undefined behavior, о чем написано в обоснованиях к C99 (с. 74, https://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf):

> The validity of this construct has always been questionable. In the response to one Defect
> Report, the Committee decided that it was undefined behavior because the array p->items
> contains only one item, irrespective of whether the space exists.

Но в gcc работа с такой конструкцией реализована, поэтому ее допустимо использовать: https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html

## 3. Call stack, как аргументы передаются в функцию?

Для этого нужно смотреть соглашения о вызовах. Существуют различные конвенции о вызовах, для Linux и архитектруы x86-64 - это System V AMD64 ABI, упомимянутый на собеседовании.

Где говорится:

> Это 64-битная платформа. Стек растет вниз. Параметры передаются в функцию через регистры rdi, rsi, rdx, rcx, r8, r9, последующие параметры передаются через стек в обратном порядке. Параметры, передаваемые через стек могут быть модифицированы вызванной функцией. Функции, вызываемые с использованием инструкции call, которая помещает адрес следующей инструкции в стек и перепрыгивает на операнд. Функции возвращаются в вызывающую функцию, используя инструкцию ret, которая извлекает значение из стека и переходит по нему. Стек выравнивается по 16-байтам непосредственно перед тем, как инструкция call вызвана.

Поэтому ответ на ваш вопрос такой: "Не все аргументы передаются через стек, часть аргументов передается через регистры".

## 4. Что происходит, когда call выходит за пределы стека?
Блок MMU ответственен за управление памятью и процесс работает с виртуальной памятью. Если блок MMU определил, что процесс вышел за пределы допустимой памяти, то MMU сгенерирует аппаратное исключение (a page fault exception). Затем page fault handler ОС прекращает процесс и освобождает занимаемую память, ассоциированную с процессом.

В конечном итоге это вызовет segmentation fault (SIGSEGV сигнал сгенерируется опреационной системой), будет создан дамп памяти в момент краша для последующего разбора (можно будет GDB подебажить).

## 5. Системные вызовы.

Механизм программы, предназначенный для запроса обслуживания у ОС.

Linux предоставляет большое кол-во системных вызовов. Они организованны в несколько категорий, таких как менеджмент процессов, менеджмент файлов, сетевые операции т менеджмент памяти.

Например, распространненые системные вызовы в Linux:

open(): Открывает файл для чтения-записи
read(): Читает из файла
write(): Пшет в файл
fork(): Создает новый процесс дублированием текущего
execve(): Заменяет текущий образ процесса новым образом процесса
waitpid(): Ожидает завершения дочернего процесса
socket(): Создает сокет для сетевого соединения
connect(): Инициирует соединение по сокету
accept(): Принимает входящее соединение по сокету
send(): Отправляет данные по сокету
recv(): принимает данные по сокету

Когда user-level приложение выполняет системный вызов, оно инициирует переход от user mode к kernel mode. Ядро выполняет запрошенные операции и возвращает управление приложению.
